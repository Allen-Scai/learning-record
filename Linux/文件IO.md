# 相关术语解释

| 术语 | 中文名称                 | 解释                                                                                                                                                                                 |
| ---- | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| MMU  | 内存管理单元             | Memory Management Unit                                                                                                                                                               |
| MIME | 多用途互联网邮件扩展类型 | 是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 |

# 1 文件描述符

## 1.1 虚拟地址空间

- 它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）
- 它对应着一段连续的内存地址，起始位置为 0。
- 之所以说虚拟是因为这个起始的0地址是被虚拟出来的， 不是物理内存的 0地址。
- `n位系统`，其虚拟地址空间的大小则为 $2^n$。例如 `32位`系统，其虚拟地址空间大小为$2^{32}$
![](images/2023-08-07-10-42-15.png)

## 1.2 直接使用物理内存的风险

1. 每个进程的地址不隔离，有安全风险。
    由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。

2. 内存效率低。
    如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现**物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中**，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。

3. 进程中数据的地址不确定，每次都会发生变化。
    由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。

使用虚拟地址后，每个进程访问的仅仅是虚拟内存空间，操作系统只需要处理好虚拟内存和物理内存之间的映射关系，就能隔离不同进程的内存空间。

## 1.3 虚拟地址空间的分区

虚拟地址空间主要分为`内核区`和`用户区`

1. 内核区：
    - 内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。
    - 内核总是驻留在内存中，是操作系统的一部分。
    - 系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。
    - 用户区：存储用户程序运行中用到的各种数据。
![](images/2023-08-07-11-27-26.png)
2. 用户区
    **每个进程的虚拟地址空间都是从0地址开始的**，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，**程序是无法直接访问物理内存的**。虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：

    - 保留区: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。
    - .text段: 代码段也称正文段或文本段，通常用于存放程序的执行代码(即CPU执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。
    - .data段: **数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态变量**。数据段属于静态内存分配(静态存储区)，可读可写。
    - .bss段: **未初始化以及初始为0的全局变量和静态变量**，操作系统会将这些未初始化变量初始化为0
    - 堆(heap)：用于存放进程运行时动态分配的内存。
        **堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问**。
        堆向高地址扩展(即“向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。
    - 内存映射区(mmap)：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。
    - 栈(stack): 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反，地址“向下生长”，分配的内存是连续的。
    - 命令行参数：存储进程执行的时候传递给main()函数的参数，argc，argv[]
    - 环境变量: 存储和进程相关的环境变量, 比如: 工作路径, 进程所有者等信息

## 1.4 文件描述符详述

在Linux操作系统中的一切都被抽象成了文件，那么一个打开的文件是如何与应用程序进行对应呢？解决方案是使用文件描述符（file descriptor，简称fd），当在进程中打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符，用于对应这个打开/新建的文件。这些文件描述符都存储在内核为每个进程维护的一个文件描述符表中。

### 1.4.1 文件描述符表

启动一个进程就会得到一个对应的虚拟地址空间，这个虚拟地址空间分为两大部分，在内核区有专门用于进程管理的模块。**Linux的进程控制块PCB（process control block）本质是一个叫做task_struct的结构体，里边包括管理进程所需的各种信息**，其中**有一个结构体叫做file ，我们将它叫做文件描述符表**，里边有一个整形索引表,用于存储文件描述符。

内核为<font color=red>每一个进程维护了一个文件描述符表，索引表中的值都是从0开始的</font>，所以在不同的进程中你会看到相同的文件描述符，但是它们指向的不一定是同一个磁盘文件。
![](images/2023-08-07-11-35-25.png)

- 打开的最大文件数
    默认能打开的最大文件数量为`1024`，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的硬件配置。

- 默认分配的文件描述符
    **当一个进程被启动之后，内核PCB的文件描述符表中就已经分配了三个文件描述符**，这三个文件描述符对应的都是当前启动这个进程的终端文件（Linux中一切皆文件，终端就是一个设备文件，在 /dev 目录中）

    ```c
    STDIN_FILENO //标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为0。
    STDOUT_FILENO //标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为1。
    STDERR_FILENO //标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为2。
    ```

    这三个默认分配的文件描述符是可以通过close()函数关闭掉，但是关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。

- 给新打开的文件分配文件描述符

    **因为进程启动之后，文件描述符表中的0,1,2就被分配出去了，因此从3开始分配**

    在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符，比如：

    通过open()函数打开 /hello.txt，文件描述符 3 被分配给了这个文件，保持这个打开状态，再次通过open()函数打开 /hello.txt，文件描述符 4 被分配给了这个文件，也就是说一个进程中不同的文件描述符打开的磁盘文件可能是同一个。
    通过open()函数打开 /hello.txt，文件描述符 3 被分配给了这个文件，将打开的文件关闭，此时文件描述符3就被释放了。再次通过open()函数打开 /hello.txt，文件描述符 3 被分配给了这个文件，也就是说打开的新文件会关联文件描述符表中最小的没有被占用的文件描述符。

总之，文件描述符的特征如下：

1. 每个进程对应的文件描述符表默认支持打开的最大文件数为 1024，可以修改
2. 每个进程的文件描述符表中都已经默认分配了三个文件描述符，对应的都是当前终端文件（/dev/tty）
3. 每打开新的文件，内核会从进程的文件描述符表中找到一个空闲的没有别占用的文件描述符与其进行关联
4. 文件描述符表中不同的文件描述符可以对应同一个磁盘文件
5. 每个进程文件描述符表中的文件描述符值是唯一的，不会重复

# 2 Linux 系统IO

每个系统都有自己的专属函数，我们习惯称其为系统函数。**系统函数并不是内核函数，因为内核函数是不允许用户使用的，系统函数就充当了二者之间的桥梁**，这样用户就可以间接的完成某些内核操作了。

## 2.1 Linux 中有关文件的系统函数

### 2.1.1 常见系统函数

```c
/*
flags: 使用什么方式打开指定的文件，这个参数对应一些宏值，需要根据实际需求指定

必须要指定的属性, 以下三个属性不能同时使用, 只能任选其一
O_RDONLY: 以只读方式打开文件
O_WRONLY: 以只写方式打开文件
O_RDWR: 以读写方式打开文件
可选属性, 和上边的属性一起使用
O_APPEND: 新数据追加到文件尾部, 不会覆盖文件的原来内容
O_CREAT: 如果文件不存在, 创建该文件, 如果文件存在什么也不做
O_EXCL: 检测文件是否存在, 必须要和 O_CREAT 一起使用, 不能单独使用: O_CREAT | O_EXCL
检测到文件不存在, 创建新文件
检测到文件已经存在, 创建失败, 函数直接返回-1（如果不添加这个属性，不会返回-1）
*/
// 打开一个已经存在的磁盘文件
/*返回的是一个文件描述符，是 int 类型的*/
int open(const char *pathname, int flags);
// 打开磁盘文件, 如果文件不存在, 就会自动创建
int open(const char *pathname, int flags, mode_t mode);

/*
参数:
fd: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件
buf: 是一个传出参数, 指向一块有效的内存, 用于存储从文件中读出的数据
传出参数: 类似于返回值, 将变量地址传递给函数, 函数调用完毕, 地址中就有数据了
count: buf指针指向的内存的大小, 指定可以存储的最大字节数
返回值:
大于0: 从文件中读出的字节数，读文件成功
等于0: 代表文件读完了，读文件成功
-1: 读文件失败了
*/
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);

/*
参数:
fd: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件
buf: 指向一块有效的内存地址, 里边有要写入到磁盘文件中的数据
count: 要往磁盘文件中写入的字节数, 一般情况下就是buf字符串的长度, strlen(buf)
返回值:
大于0: 成功写入到磁盘文件中的字节数
-1: 写文件失败了
*/
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);

/*
函数参数: fd 是文件描述符, 是open() 函数的返回值
函数返回值: 函数调用成功返回值 0, 调用失败返回 -1
*/
int close(int fd);

/*
参数:
fd: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件
offset: 偏移量，需要和第三个参数配合使用
whence: 通过这个参数指定函数实现什么样的功能
SEEK_SET: 从文件头部开始偏移 offset 个字节
SEEK_CUR: 从当前文件指针的位置向后偏移offset个字节
SEEK_END: 从文件尾部向后偏移offset个字节
返回值:
成功: 文件指针从头部开始计算总的偏移量
失败: -1
*/
off_t lseek(int fd, off_t offset, int whence);

// 拓展文件或截断文件
#include <unistd.h>
#include <sys/types.h>

int truncate(const char *path, off_t length);
int ftruncate(int fd, off_t length);
```

### 2.1.2 C 删除文件的标准库函数

`remove()` 函数的原型如下：

```c
int remove(const char *filename);
```

`remove()` 函数接受一个参数，即要删除的文件的文件名，类型为 `const char*`。它返回一个 `int` 类型的值，表示删除操作的结果。

具体说明如下：

- `filename`：要删除的文件的文件名。它可以是相对路径或绝对路径。如果文件名包含目录路径，`remove()` 函数将尝试删除指定路径下的文件。

- 返回值：如果文件成功删除，`remove()` 函数返回0；如果删除失败，它返回一个非零值，通常是一个负数。

注意事项：

- 在使用`remove()`函数删除文件之前，请确保文件被正确关闭。如果文件仍然处于打开状态，删除操作可能会失败。

- 删除文件可能对文件系统有特定的权限要求。如果你没有足够的权限来删除文件，`remove()` 函数将返回一个非零值，表示删除失败。

- 在某些操作系统中，`remove()` 函数可能无法删除被其他进程打开的文件。在这种情况下，你可能需要等待其他进程关闭文件或使用其他方法来处理文件的删除。

总之，`remove()` 函数是C语言中用于删除文件的标准库函数，它接受文件名作为参数，并返回一个表示删除操作结果的整数值。

### 2.1.3 perror

函数执行的时候，如果错误，则会给`errno`这个全局变量赋值。

`errno`是一个全局变量，只要调用的Linux系统函数有异常（返回-1）, 错误对应的错误号就会被设置给这个全局变量。这个错误号存储在系统的两个头文件中：

```c
/usr/include/asm-generic/errno-base.h
/usr/include/asm-generic/errno.h
```

# 3 文件的属性信息

## 3.1 file 命令

| 参数 | 功能                                   |
| ---- | -------------------------------------- |
| -b   | 只显示文件类型和文件编码, 不显示文件名 |
| -i   | 显示文件的 MIME 类型                   |
| -F   | 设置输出字符串的分隔符                 |
| -L   | 查看软连接文件自身文件属性             |
